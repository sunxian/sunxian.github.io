---
layout: post
title:  "mysql锁"
description: "mysql mysql锁"
date:   2025-03-05 12:52:00 +0800
categories: mysql,mariaDB
category: mysql
tags: [mysql, mariaDB]
---
# mysql锁



- **共享锁和排他锁**
- **意向锁**
- **记录锁**
- **间隙锁**
- **临键锁（Next-Key Locks）**
- **插入意向锁**
- **自增锁（AUTO-INC Locks）**
- **空间索引的谓词锁**

### 共享锁和排他锁

InnoDB 实现了标准的行级锁定机制，包含两种锁类型：**共享锁（S 锁）****和****排他锁（X 锁）**。

- **共享锁（S 锁）**：允许持有锁的事务读取某一行。
- **排他锁（X 锁）**：允许持有锁的事务更新或删除某一行。

**锁的兼容性规则**：

- 如果事务 T1 持有行 r 的共享锁（S 锁），那么其他事务 T2 对行 r 的锁请求处理如下：

- - T2 请求 S 锁可以立即授予。此时，T1 和 T2 都持有行 r 的 S 锁。
  - T2 请求 X 锁不能立即授予。

- 如果事务 T1 持有行 r 的排他锁（X 锁），那么其他事务 T2 对行 r 的任何锁请求（无论是 S 锁还是 X 锁）都不能立即授予。T2 必须等待 T1 释放锁。

### 意向锁

InnoDB 支持多粒度锁定，允许行锁和表锁共存。例如，`LOCK TABLES ... WRITE` 语句会对指定表加排他锁（X 锁）。为了实现多粒度锁定，InnoDB 使用**意向锁**。意向锁是表级锁，用于表明事务稍后需要对表中的行加哪种类型的锁（共享锁或排他锁）。

**意向锁的类型**：

- **意向共享锁（IS）**：表示事务打算对表中的某些行加共享锁。
- **意向排他锁（IX）**：表示事务打算对表中的某些行加排他锁。

**意向锁的协议**：

- 在事务对表中的某行加共享锁之前，必须先获得该表的 IS 锁或更强的锁。
- 在事务对表中的某行加排他锁之前，必须先获得该表的 IX 锁。

**锁的兼容性矩阵**：

|        | **X** | **IX** | **S** | **IS** |
| ------ | ----- | ------ | ----- | ------ |
| **X**  | 冲突  | 冲突   | 冲突  | 冲突   |
| **IX** | 冲突  | 兼容   | 冲突  | 兼容   |
| **S**  | 冲突  | 冲突   | 兼容  | 兼容   |
| **IS** | 冲突  | 兼容   | 兼容  | 兼容   |

- 如果请求的锁与现有锁兼容，则可以授予锁；否则事务需要等待冲突锁释放。
- 如果锁请求因可能导致死锁而无法授予，则会返回错误。

**意向锁的作用**：

- 意向锁不会阻塞任何操作，除非是整表请求（例如 `LOCK TABLES ... WRITE`）。
- 意向锁的主要目的是表明某个事务正在锁定表中的某些行，或者即将锁定某些行。

在 `SHOW ENGINE INNODB STATUS` 和 InnoDB 监控输出中，意向锁的事务数据类似如下：

```bash
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```

**意向锁实际作用：**

**（1）避免锁冲突**

意向锁的主要作用是避免表级锁和行级锁之间的冲突。例如：

- 如果一个事务已经对表加了排他锁（X 锁），那么其他事务无法再对表加任何锁（包括意向锁）。
- 如果一个事务已经对表加了意向排他锁（IX 锁），那么其他事务可以继续对表加意向共享锁（IS 锁），但不能加共享锁（S 锁）或排他锁（X 锁）。

**（2）提高锁管理的效率**

​    通过意向锁，InnoDB 可以快速判断表级别的锁冲突，而不需要逐行检查锁的状态。例如：

- 如果一个事务需要对表中的某些行加锁，InnoDB 会先检查表的意向锁状态。如果表的意向锁与请求的锁冲突，则事务需要等待。
- 这种方式减少了锁管理的开销，提高了并发性能。

**（3）支持多粒度锁定**

意向锁允许表级锁和行级锁共存，从而实现更灵活的锁定策略。例如：

- 一个事务可以对表加意向锁，同时对某些行加行级锁。
- 另一个事务可以对表加其他类型的意向锁，同时对其他行加行级锁。

**示例**

假设有两个事务 T1 和 T2：

**T1** 执行以下操作：

```plain
START TRANSACTION;
SELECT * FROM t WHERE id = 1 FOR UPDATE; -- 对表加 IX 锁，对 id=1 的行加 X 锁
```

**T2** 执行以下操作：

```plain
START TRANSACTION;
SELECT * FROM t WHERE id = 2 FOR SHARE; -- 对表加 IS 锁，对 id=2 的行加 S 锁
```

在这种情况下：

- T1 对表加了 IX 锁，T2 对表加了 IS 锁。由于 IX 锁和 IS 锁是兼容的，因此 T2 可以继续执行。
- 如果 T2 尝试对 id=1 的行加 S 锁，则会与 T1 的 X 锁冲突，T2 需要等待。



### 记录锁

记录锁是对索引记录的锁定。例如，`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 会阻止其他事务插入、更新或删除 `t.c1` 值为 10 的行。

- 即使表没有定义索引，InnoDB 也会创建一个隐藏的聚簇索引，并使用该索引进行记录锁定。
- 在 `SHOW ENGINE INNODB STATUS` 和 InnoDB 监控输出中，记录锁的事务数据类似如下：
- 

```plain
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```



### 间隙锁

间隙锁是对索引记录之间的间隙的锁定，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁定。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;` 会阻止其他事务在 `t.c1` 列中插入值为 15 的记录，无论该列中是否已存在该值。

- 间隙锁是性能和并发性之间的权衡，用于某些事务隔离级别。
- 如果使用唯一索引搜索唯一行，则不需要间隙锁。
- 间隙锁是“纯粹抑制性”的，其唯一目的是防止其他事务在间隙中插入数据。
- 在 `READ COMMITTED` 隔离级别下，间隙锁会被禁用。



### 临键锁（Next-Key Locks）

临键锁是索引记录上的记录锁和索引记录之前的间隙锁的组合。

- InnoDB 在搜索或扫描表索引时，会对遇到的索引记录加共享锁或排他锁。
- 临键锁不仅锁定索引记录，还锁定该记录之前的间隙。
- 默认情况下，InnoDB 在 `REPEATABLE READ` 隔离级别下使用临键锁，以防止幻读。

在 `SHOW ENGINE INNODB STATUS` 和 InnoDB 监控输出中，临键锁的事务数据类似如下：



```plain
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10080 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;
```



### 插入意向锁

插入意向锁是 INSERT 操作在插入行之前设置的一种间隙锁。它表示事务打算在某个间隙中插入数据，但不会阻塞其他事务在相同间隙的不同位置插入数据。

在 `SHOW ENGINE INNODB STATUS` 和 InnoDB 监控输出中，插入意向锁的事务数据类似如下：

```plain
RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec insert intention waiting
```



### 自增锁（AUTO-INC Locks）

自增锁是一种特殊的表级锁，用于插入到具有 `AUTO_INCREMENT` 列的表中的事务。

- 如果一个事务正在插入值，其他事务必须等待，以确保插入的行获得连续的主键值。
- `innodb_autoinc_lock_mode` 变量控制自增锁的算法，允许在自增值的连续性和插入操作的并发性之间进行权衡。

`innodb_autoinc_lock_mode` 有以下三种模式：

#### **模式 0：传统模式（Traditional）**

- 这是 MySQL 5.1 之前的行为。
- 在插入操作期间，InnoDB 会使用表级锁（`AUTO-INC` 锁）来确保自增值的连续性。
- 所有插入操作都是串行化的，即一个事务必须等待前一个事务完成插入后才能继续。
- **优点**：自增值是严格连续的。
- **缺点**：并发性能较差，尤其是在高并发插入场景下。

#### **模式 1：连续模式（Consecutive）**

- 这是 MySQL 5.1 引入的默认模式。
- 对于“简单插入”（能够预先确定插入行数的语句，如单行插入），InnoDB 会使用轻量级的锁，允许多个事务并发插入。
- 对于“批量插入”（无法预先确定插入行数的语句，如 `INSERT ... SELECT` 或 `LOAD DATA`），InnoDB 会使用表级锁（`AUTO-INC` 锁）来确保自增值的连续性。
- **优点**：在大多数场景下，自增值是连续的，同时提高了并发性能。
- **缺点**：在批量插入时，仍然需要表级锁，可能会影响并发性能。

#### **模式 2：交错模式（Interleaved）**

- 这是 MySQL 8.0 引入的模式。
- 所有插入操作都不使用表级锁，而是使用轻量级的锁，允许多个事务完全并发插入。
- 自增值的分配是交错的，即多个事务可能同时分配自增值，因此自增值可能不连续。
- **优点**：并发性能最高，适合高并发插入场景。
- **缺点**：自增值可能不连续，且在复制或恢复时可能会导致自增值的顺序不一致。

| **模式**          | **锁类型**                               | **自增值连续性** | **并发性能** | **适用场景**                     |
| ----------------- | ---------------------------------------- | ---------------- | ------------ | -------------------------------- |
| **0（传统模式）** | 表级锁                                   | 严格连续         | 低           | 需要严格自增值连续的场景         |
| **1（连续模式）** | 表级锁（批量插入）或轻量级锁（简单插入） | 大多数情况下连续 | 中           | 默认模式，适合大多数场景         |
| **2（交错模式）** | 轻量级锁                                 | 可能不连续       | 高           | 高并发插入场景，不要求自增值连续 |

### 空间索引的谓词锁

InnoDB 支持对包含空间数据的列进行空间索引。为了支持 `REPEATABLE READ` 或 `SERIALIZABLE` 隔离级别，InnoDB 使用谓词锁来处理涉及空间索引的操作。

- 空间索引包含最小边界矩形（MBR）值，InnoDB 通过在查询使用的 MBR 值上设置谓词锁来强制执行一致性读取。
- 其他事务不能插入或修改与查询条件匹配的行。

------

以上是 InnoDB 锁定机制的详细说明，涵盖了各种锁类型及其应用场景。理解这些内容对于优化数据库性能和避免并发问题非常重要。

### 参考文档

https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html#innodb-next-key-locks